Okay, Gemini. Here is the `setup.md` guide designed for an agentic coding tool to initialize the RLHF practice repository using Bun, Vite, React, TypeScript, and Jest, incorporating our structured approach and detailed explanations.

---

```markdown
# Setup Guide: RLHF Code Practice Environment

This document guides an agentic coding tool through the setup of a dedicated environment for practicing Reinforcement Learning from Human Feedback (RLHF) specifically for code generation tasks, focusing on React and TypeScript.

**Goal:** Create a structured, testable, and well-documented repository to simulate RLHF evaluation cycles, track learning, and demonstrate proficiency.

**Core Technologies:**
*   **Runtime/Package Manager:** Bun (Chosen for speed and integrated tooling)
*   **Build Tool/Dev Server:** Vite (Chosen for fast HMR and modern defaults)
*   **UI Library:** React
*   **Language:** TypeScript
*   **Testing Framework:** Jest (Industry standard, good ecosystem)
*   **Testing Utilities:** React Testing Library (Focuses on behavior), jest-dom (DOM assertions)
*   **Version Control:** Git

---

## Stage 1: Project Initialization & Git Setup

**Action:** Create the project directory and initialize Git.

```bash
# Create the main project directory
mkdir rlhf-code-practice
cd rlhf-code-practice

# Initialize Git repository
git init

# Create initial commit
git commit --allow-empty -m "Initial commit"
```

**Rationale:** Establishes the project root and sets up version control from the very beginning to track all subsequent changes.

---

## Stage 2: Bun & Basic Project Structure

**Action:** Initialize the project using Bun.

```bash
# Initialize Bun project (accepting defaults)
bun init -y

# Stage and commit the initial Bun configuration
git add package.json tsconfig.json .gitignore README.md
git commit -m "feat: initialize project with bun"
```

**Rationale:** Bun provides the fast runtime and package management foundation. `bun init` creates basic configuration files (`package.json`, `tsconfig.json`).

---

## Stage 3: Vite + React + TypeScript Integration

**Action:** Add Vite, React, and TypeScript dependencies and basic Vite configuration.

```bash
# Add Vite, React, TS core dependencies
# Note: `bun create vite` is an alternative, but adding manually gives more control here.
# We will configure Vite manually.
bun add react react-dom typescript @types/react @types/react-dom
bun add -d vite @vitejs/plugin-react

# Create vite.config.ts
touch vite.config.ts

# Create index.html at the project root
touch index.html

# Create src directory and main.tsx entry point
mkdir src
touch src/main.tsx

# Create basic App component
touch src/App.tsx
```

**File Content: `vite.config.ts`**
```typescript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
})
```

**File Content: `index.html`**
```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>RLHF Code Practice</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
```

**File Content: `src/main.tsx`**
```typescript
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)
```

**File Content: `src/App.tsx`**
```typescript
function App() {
  return (
    <div>
      <h1>RLHF Code Practice Environment</h1>
      <p>Setup successful. Ready for cycles.</p>
    </div>
  )
}

export default App
```

**Action:** Update `tsconfig.json` for React JSX.

**File Content Update: `tsconfig.json`** (Modify existing `compilerOptions`)
```json
{
  "compilerOptions": {
    // ... other options generated by `bun init` ...
    "lib": ["DOM", "DOM.Iterable", "ESNext"], // Ensure DOM libs are included
    "jsx": "react-jsx", // Add this for React JSX support
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "bundler", // Or "node" depending on preference/needs
    "skipLibCheck": true,

    /* Bundler mode */
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "esModuleInterop": true // Often helpful for CJS interop
  },
  "include": ["src", "vite.config.ts"], // Ensure src and vite config are included
  // "exclude": ["node_modules"] // Usually default, but good to be explicit if needed
}

```

**Action:** Add Vite dev script to `package.json`.

**File Content Update: `package.json`** (Add to `scripts`)
```json
{
  // ... other package.json content ...
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build", // Add build script
    "preview": "vite preview" // Add preview script
    // Test script will be added later
  }
  // ... rest of package.json ...
}
```

**Action:** Stage and commit Vite setup.

```bash
# Stage the new files and changes
git add vite.config.ts index.html src/main.tsx src/App.tsx package.json tsconfig.json

# Commit the Vite integration
git commit -m "feat: integrate Vite with React and TypeScript"
```

**Rationale:** Vite provides a fast development server and build process optimized for modern JS. React is the target UI library, and TypeScript adds static typing for robustness. Basic files (`index.html`, `main.tsx`, `App.tsx`) provide the entry point. `tsconfig.json` and `package.json` are updated for compatibility.

---

## Stage 4: Jest & React Testing Library Setup

**Action:** Add Jest, `ts-jest`, and Testing Library dependencies.

```bash
bun add -d jest @types/jest ts-jest @testing-library/react @testing-library/jest-dom jest-environment-jsdom
```

**Action:** Create Jest configuration file (`jest.config.ts`).

```bash
touch jest.config.ts
```

**File Content: `jest.config.ts`**
```typescript
import type { Config } from 'jest';

const config: Config = {
  preset: 'ts-jest', // Use ts-jest preset for TypeScript
  testEnvironment: 'jsdom', // Simulate DOM environment for React components
  setupFilesAfterEnv: ['<rootDir>/src/jest-setup.ts'], // Run setup file after env is ready
  moduleNameMapper: {
    // If you plan to use path aliases (e.g., "@/components/*"), configure them here
    // Example: '^@/(.*)$': '<rootDir>/src/$1',
  },
  // Automatically clear mock calls, instances, contexts and results before every test
  clearMocks: true,
  // Indicates which provider should be used to instrument code for coverage
  coverageProvider: "v8",
  // A map from regular expressions to paths to transformers
  transform: {
     '^.+\\.tsx?$': ['ts-jest', { /* ts-jest config options */ }],
  },
};

export default config;
```

**Action:** Create Jest setup file (`src/jest-setup.ts`).

```bash
touch src/jest-setup.ts
```

**File Content: `src/jest-setup.ts`**
```typescript
// Import jest-dom matchers like .toBeInTheDocument()
import '@testing-library/jest-dom';
```

**Action:** Update `tsconfig.json` to include Jest types.

**File Content Update: `tsconfig.json`** (Add to `compilerOptions.types`)
```json
{
  "compilerOptions": {
    // ... other options ...
    "types": ["jest", "@testing-library/jest-dom"] // Add jest and jest-dom types
  },
  // ... rest of tsconfig.json ...
}
```

**Action:** Add test script to `package.json`.

**File Content Update: `package.json`** (Add to `scripts`)
```json
{
  // ... other package.json content ...
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "test": "jest" // Add the test script
  }
  // ... rest of package.json ...
}
```

**Action:** Stage and commit testing setup.

```bash
# Stage the new files and changes
git add jest.config.ts src/jest-setup.ts package.json tsconfig.json

# Commit the testing integration
git commit -m "feat: configure Jest and React Testing Library"
```

**Rationale:** Jest provides the test runner, `ts-jest` enables running TypeScript tests, `jest-environment-jsdom` simulates a browser environment, `@testing-library/react` offers utilities for testing React components focusing on user behavior, and `@testing-library/jest-dom` adds helpful DOM assertion matchers. The setup file ensures these matchers are available globally in tests.

---

## Stage 5: Project Architecture & Example Cycle

**Action:** Create the core directory structure for RLHF cycles.

```bash
# Create the main cycles directory and an example cycle
mkdir -p src/cycles/000-example-cycle
```

**Action:** Create placeholder files within the example cycle directory.

```bash
# Create placeholder files for the example cycle
touch src/cycles/000-example-cycle/prompt.md
touch src/cycles/000-example-cycle/response_A.tsx
touch src/cycles/000-example-cycle/response_B.tsx
touch src/cycles/000-example-cycle/evaluation.md
touch src/cycles/000-example-cycle/solution.ts
touch src/cycles/000-example-cycle/solution.test.ts
```

**File Content: `src/cycles/000-example-cycle/prompt.md`**
```markdown
# Example Prompt

**Task:** Write a simple TypeScript function `add` that takes two numbers (`a` and `b`) and returns their sum.

**Constraints:**
*   Must be written in TypeScript.
*   Function name must be `add`.
*   Should handle standard number inputs.
```

**File Content: `src/cycles/000-example-cycle/evaluation.md`**
```markdown
# Evaluation: 000 - Example Cycle (Add Function)

**Chosen Response:** Response_A (or B, depending on LLM output)

**Rationale:**
*   **Response A:** [Describe Response A - e.g., Correctly implemented the `add` function as specified.]
*   **Response B:** [Describe Response B - e.g., Incorrectly named the function `sum` or used `any` types.]
*   **Comparison:** Response A followed all constraints of the prompt, including function name and type annotations, whereas Response B failed on [specific constraint].

**Feedback Provided (if applicable):**
*   [If Response A had minor flaws, e.g., "Feedback provided to use number types explicitly instead of relying on inference."]

**LLM Flaws Observed:**
*   [Note any interesting mistakes, e.g., "Response B demonstrated a tendency to deviate from specified naming conventions."]

**Key Learning:**
*   Even simple prompts require checking adherence to all constraints.
```

**File Content: `src/cycles/000-example-cycle/solution.ts`**
```typescript
/**
 * Adds two numbers.
 * @param a The first number.
 * @param b The second number.
 * @returns The sum of a and b.
 */
export function add(a: number, b: number): number {
  return a + b;
}
```

**File Content: `src/cycles/000-example-cycle/solution.test.ts`**
```typescript
import { add } from './solution';

describe('RLHF Cycle: 000 - Example (Add Function)', () => {
  describe('Ideal Solution (solution.ts)', () => {
    it('should add two positive numbers correctly', () => {
      expect(add(2, 3)).toBe(5);
    });

    it('should add a positive and a negative number correctly', () => {
      expect(add(5, -3)).toBe(2);
    });

    it('should add two negative numbers correctly', () => {
      expect(add(-2, -3)).toBe(-5);
    });

    it('should add zero correctly', () => {
      expect(add(5, 0)).toBe(5);
      expect(add(0, 0)).toBe(0);
    });
  });

  // Add describe blocks here later to test LLM responses if needed
  // describe('LLM Response A Analysis (response_A.ts)', () => { ... });
});
```

**Action:** Stage and commit the directory structure and example.

```bash
# Stage the new directory and files
git add src/cycles/

# Commit the architecture setup
git commit -m "feat: establish core project architecture with example cycle"
```

**Rationale:** This establishes the standardized structure for each RLHF practice cycle. Each cycle is self-contained, including the prompt, AI responses, your evaluation, the correct solution, and tests. This modularity makes the process repeatable and organized. The example provides a clear template.

---

## Stage 6: Master README.md

**Action:** Overwrite the initial `README.md` with comprehensive project documentation.

**File Content: `README.md`**
```markdown
# RLHF Code Practice Environment

This repository serves as a dedicated environment for practicing and documenting Reinforcement Learning from Human Feedback (RLHF) cycles focused on improving AI code generation, primarily using React and TypeScript.

The core goal is to systematically:
1.  Define coding prompts.
2.  Generate multiple code solutions using Large Language Models (LLMs).
3.  Rigorously evaluate these solutions based on correctness, scope adherence, quality, and best practices.
4.  Document the evaluation rationale and provide constructive feedback.
5.  Implement and test an ideal solution.
6.  Track insights and learnings throughout the process.

This structured practice aims to deepen understanding of effective RLHF for code, refine evaluation skills, and produce a demonstrable body of work.

## Technology Stack

*   **Runtime/Package Manager:** [Bun](https://bun.sh/) - Chosen for its exceptional speed and integrated tooling (bundler, test runner, package manager).
*   **Build Tool/Dev Server:** [Vite](https://vitejs.dev/) - Provides a fast development experience with Hot Module Replacement (HMR) and sensible defaults for modern web development.
*   **UI Library:** [React](https://react.dev/) - The primary target library for frontend code generation tasks in this practice environment.
*   **Language:** [TypeScript](https://www.typescriptlang.org/) - Adds static typing for increased code robustness, maintainability, and improved developer experience, crucial for evaluating high-quality code.
*   **Testing Framework:** [Jest](https://jestjs.io/) - A popular and feature-rich JavaScript testing framework, well-suited for unit and integration testing.
*   **Testing Utilities:**
    *   [@testing-library/react](https://testing-library.com/docs/react-testing-library/intro): Facilitates testing React components by focusing on user interactions and accessibility, aligning well with evaluating practical code usability.
    *   [@testing-library/jest-dom](https://github.com/testing-library/jest-dom): Provides custom Jest matchers for improved assertions on DOM nodes.
*   **Version Control:** [Git](https://git-scm.com/) - For tracking changes and managing the project history.

## Project Architecture

The core of the practice happens within the `src/cycles/` directory. Each subdirectory inside `cycles/` represents a single, self-contained RLHF evaluation cycle.

```
rlhf-code-practice/
├── src/
│   ├── cycles/
│   │   ├── 000-example-cycle/    # Represents one RLHF task/prompt
│   │   │   ├── prompt.md         # The specific prompt given to the LLM
│   │   │   ├── response_A.tsx    # LLM's first code attempt
│   │   │   ├── response_B.tsx    # LLM's second code attempt
│   │   │   ├── evaluation.md     # Your detailed analysis, comparison & feedback
│   │   │   ├── solution.ts       # Your corrected/ideal solution code
│   │   │   └── solution.test.ts  # Jest tests verifying the solution
│   │   │
│   │   └── ... (more cycles) ... # Subsequent practice cycles
│   │
│   ├── jest-setup.ts             # Setup for Jest (e.g., importing jest-dom)
│   ├── App.tsx                   # Basic React App shell (if needed for rendering tests)
│   └── main.tsx                  # React entry point
│
├── .gitignore
├── jest.config.ts                # Jest configuration
├── package.json                  # Project dependencies and scripts
├── bun.lockb                     # Bun lockfile
├── tsconfig.json                 # TypeScript configuration
├── vite.config.ts                # Vite configuration
├── index.html                    # HTML entry point for Vite
└── README.md                     # This file
```

### Function of Key File Types within a Cycle:

*   `prompt.md`: Contains the exact instructions given to the LLM for the code generation task. Should be clear and specific.
*   `response_X.tsx`/`.ts`: Raw code output generated by the LLM for the given prompt. Multiple responses (A, B, etc.) allow for comparison.
*   `evaluation.md`: The core of the human feedback. This file documents:
    *   Which LLM response was chosen as superior (or if both were inadequate).
    *   A detailed rationale comparing the responses against the prompt requirements, correctness, code quality, and best practices.
    *   Specific feedback points or corrections suggested.
    *   Any observed patterns or interesting flaws in the LLM's output.
    *   Personal learnings or insights gained from the cycle.
*   `solution.ts`/`.tsx`: Your implementation of the correct or ideal solution according to the prompt and best practices. This serves as a reference and target for testing.
*   `solution.test.ts`/`.tsx`: Contains Jest/RTL tests that verify the functionality defined in `prompt.md`. These tests should pass against your `solution` code and can be used to objectively demonstrate flaws in the `response_X` code.

## Workflow for Adding a New Cycle

1.  **Create Directory:** Create a new numbered directory under `src/cycles/` (e.g., `src/cycles/001-new-feature/`).
2.  **Define Prompt:** Write the prompt in `prompt.md`.
3.  **Generate Responses:** Use an LLM to generate 2-3 code solutions and save them as `response_A.tsx`, `response_B.tsx`, etc.
4.  **Write Tests:** Create `solution.test.ts` and write tests defining the expected behavior based *only* on the `prompt.md`.
5.  **Evaluate:** Run the tests against the LLM responses (they might fail). Manually review the responses. Write your detailed analysis, comparison, and choice in `evaluation.md`.
6.  **Implement Solution:** Write your ideal code in `solution.ts`/`.tsx`, ensuring it passes all tests in `solution.test.ts`.
7.  **Commit:** Stage and commit the new cycle directory with a descriptive message (e.g., `feat(cycle): add 001-new-feature RLHF practice`).

## Running the Project

**1. Installation:**
   Requires [Bun](https://bun.sh/docs/installation).
   ```bash
   bun install
   ```

**2. Development Server (Optional - for testing components):**
   If a cycle involves React components you want to render visually.
   ```bash
   bun run dev
   ```
   (You would need to import and render components from specific cycles into `src/App.tsx` for this).

**3. Running Tests:**
   This is the primary way to verify solutions and check LLM responses against requirements.
   ```bash
   bun run test
   ```
   This command will execute all `*.test.ts` files within the `src/cycles/` directory. Review the Jest output for detailed results per cycle. Tests under "Ideal Solution" should pass. Tests under "LLM Response X Analysis" might be designed to fail to demonstrate evaluated flaws.

## Contributing / Using This Repository

This repository is primarily for personal RLHF practice. However, others are welcome to:
*   Browse the cycles to understand the evaluation process.
*   Clone the repository and run `bun run test` to see the test results for implemented solutions.
*   Adapt the structure for their own RLHF practice.

---
```

**Action:** Stage and commit the final README.md.

```bash
# Stage the updated README.md
git add README.md

# Commit the final documentation
git commit -m "docs: add comprehensive project README"
```

---

**Setup Complete.** The `rlhf-code-practice` directory now contains a fully configured project ready for systematic RLHF practice cycles. The agent should now be able to follow the workflow described in the `README.md` to add new cycles.

```